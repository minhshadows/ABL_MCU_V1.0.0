/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f401re_gpio.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_adc.h"
#include "stm32f401re_tim.h"
#include "misc.h"
#include "timer.h"
#include "kalman_filter.h"
/*Define-------------------------------------------------------------------------------*/
#define ADC_PORT						GPIOC
#define ADC_PIN							GPIO_Pin_5
#define Tim_Period						8399
//#define lux_max							3400

/*Variables----------------------------------------------------------------------------*/
uint16_t AdcValue = 0;
uint16_t lux_max = 2500;
uint16_t lux =0;
uint8_t Duty_Cycle = 0;
uint8_t Duty_Cycle_Current = 0;
uint8_t Duty_Cycle_old = 0;
uint32_t Time_Init = 0;
uint32_t TimeCurrent = 0;
uint32_t TimeTotal = 0;

/*Functions----------------------------------------------------------------------------*/
void LightSensor_AdcInit();
void LedControl_TimerOCInit();
uint16_t LightSensor_AdcPollingRead();
void LedControl_TimerOCSetPwm( uint16_t Duty_Cycle);
void ABL_StepBrightness(uint16_t Value);
void ABL_Process();
uint32_t CalculatorTime(uint32_t dwTimeInit, uint32_t dwTimeCurrent);
static void AppInitCommon();

/**
 * @func	LightSensor_AdcInit
 *
 * @brief	Initialization ADC polling mod
 *
 * @param	none
 *
 * @retval	none
 */
void LightSensor_AdcInit()
{
	GPIO_InitTypeDef		GPIO_InitStructure;
	ADC_InitTypeDef 		ADC_InitStructure;
	ADC_CommonInitTypeDef 	ADC_CommonInitStructure;

	//Initial GPIO
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_Pin = ADC_PIN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(ADC_PORT, &GPIO_InitStructure);

	//cấp clock cho ADC
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	ADC_DeInit();

	//ADC Common Init----------------------------------------------------------
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_15Cycles;

	ADC_CommonInit(&ADC_CommonInitStructure);

	// ADC Init-----------------------------------------------------------------
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_NbrOfConversion = 1;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;

	ADC_Init(ADC1,&ADC_InitStructure);

	ADC_RegularChannelConfig(ADC1, ADC_Channel_15, 1, ADC_SampleTime_15Cycles);

	ADC_Cmd(ADC1, ENABLE);


}

/**
 * @func	LedControl_TimerOCInit
 *
 * @brief	Initialization Timer Output Compare mode
 *
 * @param	none
 *
 * @retval	none
 */
void LedControl_TimerOCInit()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	TIM_TimeBaseInitTypeDef Timer_InitStructure;
	TIM_OCInitTypeDef TIM_OCInitStructure;

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);

	//Initialize GPIO Use Output Compare
	// led green left board
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF ;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 ;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_TIM1);

	GPIO_Init(GPIOA,&GPIO_InitStructure);
	//led green right board
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF ;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 ;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz ;

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM2);

	GPIO_Init(GPIOA,&GPIO_InitStructure);

	//Enable clock timer
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	/*Tim1----------------------------------------------------------------------*/
	//Enable basic timer
	Timer_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	Timer_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	Timer_InitStructure.TIM_Period = Tim_Period;
	Timer_InitStructure.TIM_Prescaler = 0;
	Timer_InitStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit( TIM1,&Timer_InitStructure);

	//Enable General purpose timer
	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 0;

	TIM_OC4Init(TIM1, &TIM_OCInitStructure);

	TIM_Cmd(TIM1, ENABLE);

	TIM_CtrlPWMOutputs(TIM1, ENABLE);

	/*Tim2----------------------------------------------------------------------*/
	Timer_InitStructure.TIM_CounterMode = TIM_CounterMode_Up ;
	Timer_InitStructure.TIM_Prescaler = 0 ;
	Timer_InitStructure.TIM_Period = 8399 ;
	Timer_InitStructure.TIM_ClockDivision = 0 ;
	Timer_InitStructure.TIM_RepetitionCounter = 0 ;

	TIM_TimeBaseInit( TIM2,&Timer_InitStructure);

	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2 ;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable ;
	TIM_OCInitStructure.TIM_Pulse = 0 ;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low ;

	TIM_OC1Init(TIM2, &TIM_OCInitStructure);

	TIM_Cmd(TIM2, ENABLE);// cho phép Timer hoạt động

	TIM_CtrlPWMOutputs(TIM2, ENABLE); //cho phép timer hoạt động ở chế độ OC
}

/**
 * @func	LightSensor_AdcPollingRead
 *
 * @brief	Get data of light from ADC1
 *
 * @param	none
 *
 * @retval	value of light
 */
uint16_t LightSensor_AdcPollingRead()
{
	uint16_t result = 0 ;
	/*Start ADC1 Software Conversion*/
	ADC_SoftwareStartConv(ADC1);

	while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) ==  RESET);

	result = ADC_GetConversionValue(ADC1);

	return result;
}

/**
 * @func	LedControl_TimerOCSetPwm
 *
 * @brief	Calculate pulse & set PWM
 *
 * @param	[Duty_Cycle]
 *
 * @retval	none
 */
void LedControl_TimerOCSetPwm( uint16_t Duty_Cycle)
{
	static uint16_t pulse_lenght = 0 ;
	// calculator pulse_lenght
	pulse_lenght = ((Tim_Period * Duty_Cycle)/100);

	//set pulse_lenght to timer
	TIM_SetCompare4(TIM1, pulse_lenght);
	TIM_SetCompare1(TIM2, pulse_lenght);
}

/**
 * @func	LED_StepBrightness
 *
 * @brief	increase or decrease duty cycle
 *
 * @param	none
 *
 * @retval	none
 */
void LED_StepBrightness()
{
	if(Duty_Cycle_old > Duty_Cycle)
	{
		Duty_Cycle_Current--;
		LedControl_TimerOCSetPwm(Duty_Cycle_Current);
	}
	else if(Duty_Cycle_old < Duty_Cycle)
	{
		Duty_Cycle_Current++;
		LedControl_TimerOCSetPwm(Duty_Cycle_Current);
	}
	else if(Duty_Cycle_old == Duty_Cycle)
	{
		Duty_Cycle_Current = Duty_Cycle;
		LedControl_TimerOCSetPwm(Duty_Cycle_Current);
	}
	else // duty_cycle == 0
	{
		Duty_Cycle_Current = 1;
		LedControl_TimerOCSetPwm(Duty_Cycle_Current);
	}
	Duty_Cycle_old = Duty_Cycle;
}

/**
 * @func	ABL_StepBrightness
 *
 * @brief	Calculate duty cycle
 *
 * @param	none
 *
 * @retval	none
 */
void ABL_StepBrightness(uint16_t Value)
{
	Duty_Cycle = ((float)Value/(float)lux_max)*100;
	LED_StepBrightness();
}

/**
 * @func	ABL_Process
 *
 * @brief	process value of light
 *
 * @param	none
 *
 * @retval	none
 */
void ABL_Process()
{
	TimeCurrent = GetMilSecTick();
	if(TimeCurrent >= Time_Init)
	{
		TimeTotal += TimeCurrent - Time_Init;
	}
	else
	{
		TimeTotal += 0xFFFFFFFFU - TimeCurrent + Time_Init;
	}

	if(TimeTotal>=100) // quét độ sáng mỗi 100ms/lần
	{
		AdcValue = LightSensor_AdcPollingRead();
		lux = KalmanFilter_updateEstimate(AdcValue);
		TimeTotal=0;
	}

	if((TimeTotal % 20) == 0) // 20ms thay đổi độ sáng 1 lần
	{
		ABL_StepBrightness(lux);
	}
}

/**
 * @func	AppInitCommon
 *
 * @brief	Initialization Peripheral and sensor
 *
 * @param	none
 *
 * @retval	none
 */
static void AppInitCommon()
{
	SystemCoreClockUpdate();
	TimerInit();
	LightSensor_AdcInit();
	LedControl_TimerOCInit();
	KalmanFilterInit(0.1,1,0.01);
	Time_Init = GetMilSecTick();
}

int main(void)
{
	AppInitCommon();
    while(1)
    {
    	processTimerScheduler();
    	ABL_Process();
    }
    return 0;
}
